# LAB5

## 实验总结

> 我在例程代码的基础上实现了对 mutex 和 semaphore 的死锁检测。

## 简答作业

在我们的多线程实现中，当主线程 (即 0 号线程) 退出时，视为整个进程退出， 此时需要结束该进程管理的所有线程并回收其资源。 
- 需要回收的资源有哪些？ 
	- 进程申请的内存
	- 关闭打开的文件
- 其他线程的 TaskControlBlock 可能在哪些位置被引用，分别是否需要回收，为什么？
	- 可能在系统调用等地方被引用
	- 需要，在主线程回收时一并被回收，因为他们属于一个进程

对比以下两种 Mutex.unlock 的实现，二者有什么区别？这些区别可能会导致什么问题？

```
impl Mutex for Mutex1 {
    fn unlock(&self) {
        let mut mutex_inner = self.inner.exclusive_access();
        assert!(mutex_inner.locked);
        mutex_inner.locked = false;
        if let Some(waking_task) = mutex_inner.wait_queue.pop_front() {
            add_task(waking_task);
        }
    }
}

impl Mutex for Mutex2 {
    fn unlock(&self) {
        let mut mutex_inner = self.inner.exclusive_access();
        assert!(mutex_inner.locked);
        if let Some(waking_task) = mutex_inner.wait_queue.pop_front() {
            add_task(waking_task);
        } else {
            mutex_inner.locked = false;
        }
    }
}
```

- 第一种：如果在将锁状态设为 false 之后，有一个线程尝试获取锁并成功获取，然后在检查等待队列之前又有另一个线程被唤醒，那么这个被唤醒的线程可能会发现自己已经获取了锁，而实际上锁已经被其他线程持有
- 第二种：对于部分分支不会更新锁的状态。

## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 **以下各位** 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

```
杨学聪(笔者):
请教各位大佬信号量死锁检测的思路，我想到的只有在 down 时检测,对应 count 是否大于 0，银行家的方法因为 NEED 没有一次性给出有点理解不了，应该怎么考虑呢

My:
你换个思路, 这个矩阵也是内存里的一段数据, 可以随时随地随便改对吧

My:
而所谓资源, 先后创建两个mutex, 这是两种不同的资源, 需要给这个矩阵增加资源上限

Dynamic_Pigeon:
其实第一步，抛开银行家算法

李十八:
阶段三是要把几个方向都要做一遍吗 还以为只要挑一个方向做就行

皮稻:
都可以

皮稻:


Dynamic_Pigeon:
因为银行家算法不可实现，所以考虑用类似的方法解决

Dynamic_Pigeon:
比如动态的 need 矩阵

My:
系统调用发生的时候, 到你操作内核代码进入等待锁, 中间到处都是你可以插入代码的位置

李十八:
按照题目的描述 实现就行捏 就是一个能不能获取到资源的判断吧(我感觉

皮稻:
我的写法就是need就是在你分配不到了就增加

皮稻:
所谓need，就是你need了

皮稻:
[动画表情]

My:
所以, 就先试着把资源(在矩阵里)拨给申请线程, 然后跑一遍银行家算法

My:
如果银行家算法通过了, ok没死锁

李十八:
down的时候设置need 然后去检测还要动态调整三个的内容， up的时候只需要释放资源这样

My:
如果银行家算法不通过, 说明死锁, 回滚资源分配, 告诉调用线程会发生死锁, 拒绝

李十八:
在理

杨学聪:
@My 是不是就是，将某个 task 对每个资源的 need 的 vec 绑进 inner 结构中，检测时增加对应 need 值进行判断（）

My:
不只是need

My:
信号量是线程可以提供的资源, 提供后增加了银行的上限

My:
线程也在动态创建/删除
资源也在动态生成/申请/销毁
这个三维矩阵里有两个维度要随着一起增减

杨学聪:
@My @李十八 @皮稻 @Dynamic_Pigeon 感谢感谢，我好像明白一点了
```

2. 此外，我也参考了 **以下资料** ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

    > https://learningos.cn/rCore-Tutorial-Guide-2024S/index.html （教材）

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
